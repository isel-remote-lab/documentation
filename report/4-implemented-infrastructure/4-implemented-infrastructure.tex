%
% Chapter 4
%
\chapter{Implemented Infrastructure} \label{cap:implemented-infrastructure}

This chapter details the infrastructure implemented for the Remote Lab platform, covering the main components, technologies, deployment strategy, and integration between system modules.

\section{Overview}

The Remote Lab platform is designed as a modular, containerized system that enables secure and efficient remote access to laboratory equipment. The infrastructure follows a layered architecture, separating the user interface, backend logic, and hardware integration, and is built with scalability and maintainability in mind.

\begin{figure}[h]
    \begin{center}
        \resizebox{16cm}{!}{\includegraphics{../img/SystemArchitectureWithTechRL.png}}
    \end{center}
    \caption{System Architecture Overview}
    \label{fig:system-architecture}
\end{figure}

\input{4-implemented-infrastructure/4.2-project-structure/4.2-project-structure.tex}

\input{4-implemented-infrastructure/4.3-implementation-details/4.3-implementation-details.tex}

\section{Database}
The database serves as the foundational component of the system architecture. PostgreSQL was selected as the database management system due to its reliability, open-source nature, and robust support for relational data models. This choice aligns with previous project implementations and provides the consistency and performance required for the system's operational needs.

This section presents a overview of the \ac{er model} and critical implementation details. Complete technical documentation is provided in the accompanying appendix.

\subsection{Entity-Relationship Model}

\begin{figure}[H]
    \begin{center}
        \resizebox{17cm}{!}{\includegraphics{../img/DB-diagrams/ERDiagramRL.drawio.png}}
    \end{center}
    \caption{Entity-Relationship Model (ER Model)}
    \label{fig:er_model}
\end{figure}

The database design follows a normalized relational structure that supports user authentication, secure session management, and the remaining system functionalities. The ER model encompasses the core entities required for system functionality while maintaining data integrity and scalability.

\subsection*{Core Entities}
\subsection*{User}

\begin{figure}[H]
    \begin{center}
        \resizebox{10cm}{!}{\includegraphics{../img/DB-diagrams/User.drawio.png}}
    \end{center}
    \caption{User Entity}
    \label{fig:user_entity}
\end{figure}

The \textbf{User} entity represents a user in the system. The username and email attributes are provided by the authentication system. The role serves as descriminator attribute to identify whether the user is an administrator, professor or student.

\subsection*{Token}

\begin{figure}[H]
    \begin{center}
        \resizebox{10cm}{!}{\includegraphics{../img/DB-diagrams/Token.drawio.png}}
    \end{center}
    \caption{Token Entity}
    \label{fig:token_entity}
\end{figure}

A user can create \textit{N} tokens. The \textbf{Token} is a weak entity because it cannot be identified by its attributes alone and therefore requires a user, which is a strong entity, to be identified. Its attributes cannot uniquely identify it. A token is created by only one user.

This is a useful entity for authentication propuses. It was designed to hold a hash value in the \textit{token\_validation} attribute.

Authentication workflow:

\begin{enumerate}
    \item Upon successful user login, a unique token is created with cryptographically secure values and stored in the database.
    \item For subsequent authenticated operations, the system queries the database to verify the client-provided token against stored values.
    \item Valid tokens enable secure user identification without transmitting unique identifiers.
\end{enumerate}

The \textit{last\_used\_at} and the \textit{created\_at} are useful for determining token expiration.

\subsection*{Laboratory}

\begin{figure}[H]
    \begin{center}
        \resizebox{10cm}{!}{\includegraphics{../img/DB-diagrams/Laboratory.drawio.png}}
    \end{center}
    \caption{Laboratory Entity}
    \label{fig:laboratory_entity}
\end{figure}

A user, as an administrator or professor, can create \textit{N} laboratories. When creating a \textbf{Laboratory}, the user can define the name (\textit{lab\_name}) and description (\textit{lab\_description}). They can also define the duration of a laboratory session (\textit{lab\_duration}) and its queue limit (\textit{lab\_queue\_limit}).

\subsection*{Hardware}

\begin{figure}[H]
    \begin{center}
        \resizebox{10cm}{!}{\includegraphics{../img/DB-diagrams/Hardware.drawio.png}}
    \end{center}
    \caption{Hardware Entity}
    \label{fig:hardware_entity}
\end{figure}

Upon successful laboratory creation, the user can associate \textbf{Hardware} to it, which must be created separately.

For the creation, it requires a name (\textit{hw\_name}), IP (\textit{ip\_address}) and MAC (\textit{mac\_address}) addresses (which can be null depending on the hardware), a status (\textit{hw\_status}) to indicate whether the hardware is under maintenance, occupied, or available, and a serial number (\textit{hw\_serial\_num}) to uniquely identify the hardware. Although it has an ID, the serial number helps physically identify the hardware.    

\subsection*{Group}

\begin{figure}[H]
    \begin{center}
        \resizebox{9cm}{!}{\includegraphics{../img/DB-diagrams/Group.drawio.png}}
    \end{center}
    \caption{Group Entity}
    \label{fig:group_entity}
\end{figure}

For a student to access a laboratory, they must be in a group that is associated with that laboratory. A professor can create a \textbf{Group} and associate users to it.

When creating a group, the user needs to name it (\textit{group\_name}) and, optionally, add a description (\textit{group\_description}) to it.

\subsection*{Lab Session}

\begin{figure}[H]
    \begin{center}
        \resizebox{7.5cm}{!}{\includegraphics{../img/DB-diagrams/LabSession.drawio.png}}
    \end{center}
    \caption{Lab Session Entity}
    \label{fig:lab_session_entity}
\end{figure}

Finally, a user can join a laboratory if they are in a group associated with it. If the laboratory is being used, the user enters a waiting queue; otherwise, a \textbf{Lab Session} is created.

Lab Session is a weak entity. It requires two strong entities to be identified: the \textbf{User} entity and the \textbf{Laboratory} entity. This is used to check whether a user is in a lab session or for statistical purposes. The \textit{state} attribute indicates whether the session is over or still running. The \textit{start\_time} and \textit{end\_time} can be used for statistical details, such as determining how much time a user spent in a laboratory, or for future purposes, such as scheduling sessions.

\subsection{Implementation Details}
After providing an overview of the database entities and their associations, there are important details worth mentioning:

\begin{itemize}
    \item Although PostgreSQL is being used for its functionalities, it was decided that all logic and verifications are implemented in the Web API, so that no triggers or complex constraints are implemented on the database side.
\end{itemize}

\subsection{Conclusion}
This section has provided an overview of the database architecture, implementation, and design decisions. It has also presented the \acs{er model} of the database and described a typical user journey, explaining database interactions.

The documentation should be consulted for a comprehensive deep dive. It explains every entity, its attributes, and provides theoretical insights.

\section{Web API}
The Web API provides endpoints for user management, authentication, authorization, and CRUD operations. 

The API is developed with Kotlin and Spring Boot, and follows the Controller-Service-Repository pattern, which is prevalent in many Spring Boot applications. We chose this pattern because of the separation of concerns it provides and the possibilities for unit testing.

To make the codebase even easier to maintain and improve the quality of life during development, Spring Framework's Inversion of Control container (COLOCAR REFERENCIA) and the Strategy pattern principle were also used. 

Spring's dependency injection is a well-known technology in Java enterprise programming. It provides an easy way to declare dependencies, since the API was mostly built following Object Oriented Programming (OOP) principles. This framework allows us to declare the necessary dependencies for each module. It also provides a BeanFactory interface for advanced configurations. Using these Spring technologies moves the object management to Spring.

The Strategy pattern allowed us to have more control over the specific implementation since it follows an interface. Every concrete implementation follows an interface, making it possible to change a class dynamically without changing the code. Spring's dependency injection works very well with this strategy design pattern. This makes unit tests much easier when the concrete implementation is not intended to be tested without changing it's code.

\begin{figure}[H]
    \begin{center}
        \resizebox{15cm}{!}{\includegraphics{../img/api/api_architecture.drawio.png}}
    \end{center}
    \caption{API Architecture}
    \label{fig:api_architecture}
\end{figure}

Figure \ref{fig:api_architecture} provides a simple overview of the implemented \acs{api}. The \textbf{HTTP} module (Controller) is responsible for exposing the endpoints and handling the messages. When a request is made, the HTTP module receives the request and hands it to the \textbf{Service} module. This is where the logic and verifications are performed. Since it is necessary to fetch and save data, a \textbf{Repository} module is needed. The repository module is responsible for communicating with the database.

\vspace{3mm}

\begin{figure}[H]
    \begin{center}
        \resizebox{15cm}{!}{\includegraphics{../img/api/detailed_architecture.drawio.png}}
    \end{center}
    \caption{API Detailed Architecture}
    \label{fig:api_detailed_architecture}
\end{figure}

Figure \ref{fig:api_detailed_architecture} provides a more detailed overview of how the architecture is composed. 

As explained, the HTTP module contains the controllers, each one with its functions. The pipeline contains the argument resolvers and interceptors. For the implemented system, only one argument resolver and two interceptors were implemented. The argument resolver (COLOCAR REFERENCIA) is used to provide user information to the controllers. Since the authentication method we used was token-based, this argument resolver extracts user information from the request. Every controller that has a parameter with the type \textit{AuthenticatedUser} will be authenticated. 

For the request to contain the needed information about the user, an interceptor is required. This is one of the two interceptors implemented. Every request, before reaching the controller, passes through every configured interceptor. This authentication interceptor checks if the handler parameters contain a parameter of the type \textit{AuthenticatedUser}. If it does, the entire process of getting the token from the request, verifying it, and retrieving the user is performed. If not, normal execution continues.
\begin{center}
    \begin{lstlisting}[caption={Type AuthenticatedUser verification example}]
    if (handler is HandlerMethod &&
        handler.methodParameters.any {
            it.parameterType == AuthenticatedUser::class.java
        }
    )
    \end{lstlisting}
\end{center}

The other interceptor is for an API key. It checks if the handler contains a custom annotation. If yes, the API key is validated; if not, an unauthorized response is sent. This interceptor is useful for the login endpoint. This login endpoint is to be performed in the Web App and is not meant to be used by end users.

The service module performs the necessary checks, using domain classes defined in the Domain module. These classes provide configurations and methods for validating certain data. Configurations in domain classes are provided by a JSON file containing domain restrictions.

\begin{center}
    \begin{lstlisting}[caption={Example of the group entry}]
        "group": {
            "groupName": {
              "min": 3,
              "max": 100,
              "optional": false
            },
            "groupDescription": {
              "min": 10,
              "max": 1000,
              "optional": true
            }
          }
    \end{lstlisting}
\end{center}

This JSON file is converted to a class using Kotlin Serialization. This allows an easy way to change specific values without touching the codebase.

\vspace{3mm}

Every response, whether successful or an error, follows a specific format. The API documentation provides an overview of the possible responses. Error messages follow the application/problem+json format (COLOCAR REFERENCIA).

\vspace{3mm}

The API is expected to be public, providing full documentation (COLOCAR REFERENCIA POSTMAN) in Postman. It was decided to have the documentation in Postman because of the easy-to-use documentation builder inside the collection containing the tests for the endpoints. The API key is implemented for this reason. In future work, when the API reaches a stable version to be made public, users who want to use it will need to log in to the website and generate a token to use the API.

\input{4-implemented-infrastructure/4.6-web-application/4.6-web-application.tex}

\input{4-implemented-infrastructure/4.7-deployment/4.7-deployment.tex}

\section{Technologies Used}

\begin{itemize}
    \item \textbf{Frontend:} Implemented with Next.js (React framework), providing a modern, responsive web interface for users to interact with laboratories, schedule sessions, and control hardware.
    \item \textbf{Backend:} Developed in Kotlin using Spring Boot, exposing RESTful APIs for user management, authentication, laboratory session control, and business logic enforcement.
    \item \textbf{Database:} PostgreSQL is used to persist user data, session information, access logs, and configuration settings.
    \item \textbf{ORM/Database Access:} JDBI is used for type-safe, modular database access in the backend.
    \item \textbf{Authentication:} Microsoft OAuth via NextAuth is used for user authentication, supporting multiple roles (student, professor, administrator).
    \item \textbf{Containerization:} Docker is used to containerize all major components (frontend, backend, database), ensuring consistent deployment across environments.
    \item \textbf{Orchestration:} Docker Compose manages multi-container deployment, networking, and environment configuration.
\end{itemize}

\section{System Components}

\begin{itemize}
    \item \textbf{Web Application (Frontend):} Provides dashboards, laboratory access, real-time hardware monitoring, and session management. Built with Next.js and deployed as a Docker container.
    \item \textbf{API Server (Backend):} Handles authentication, authorization, laboratory and user management, and hardware abstraction. Built with Kotlin and Spring Boot, also containerized.
    \item \textbf{Database:} PostgreSQL instance running in a Docker container, with persistent storage volumes.
    \item \textbf{Hardware Abstraction Layer:} Backend modules abstract hardware-specific details, exposing unified interfaces for laboratory equipment control.
\end{itemize}

\section{Deployment Architecture}

The system is deployed using Docker Compose, which defines and manages the following services:

\begin{itemize}
    \item \textbf{db:} PostgreSQL database container, with health checks and persistent volumes.
    \item \textbf{api:} Backend API container, built from the Kotlin/Spring Boot project, depending on the database service.
    \item \textbf{website:} Frontend container, built from the Next.js project, depending on the API service.
\end{itemize}

All services are connected via Docker networks to ensure secure and efficient communication. Environment variables and secrets are managed via \texttt{.env} files.

\section{Build and CI/CD}

\begin{itemize}
    \item \textbf{Gradle:} Used for building and managing backend dependencies.
    \item \textbf{NPM:} Used for frontend dependency management and builds.
    \item \textbf{Dockerfiles:} Multi-stage builds are used for both backend and frontend to optimize image size and security.
    \item \textbf{GitHub Actions:} (If applicable) Used for continuous integration and automated builds.
\end{itemize}

\section{Notable Implementation Details}

\begin{itemize}
    \item The backend uses JDBI for database access, configured with application-specific requirements.
    \item Environment variables are used to configure database connections and secrets, improving security and flexibility.
    \item The system supports role-based access control, with different permissions for students, professors, and administrators.
    \item The hardware abstraction layer allows for future extension to new types of laboratory equipment.
\end{itemize}

\section{Summary}

The implemented infrastructure leverages modern web technologies, containerization, and modular design to provide a robust, scalable, and maintainable platform for remote laboratory access.